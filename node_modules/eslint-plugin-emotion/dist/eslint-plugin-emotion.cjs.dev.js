'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var importFromEmotion = {
  meta: {
    fixable: 'code'
  },
  create: function create(context) {
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.value === 'react-emotion' && node.specifiers.some(function (x) {
          return x.type !== 'ImportDefaultSpecifier';
        })) {
          context.report({
            node: node.source,
            message: "emotion's exports should be imported directly from emotion rather than from react-emotion",
            fix: function fix(fixer) {
              if (node.specifiers[0].type === 'ImportNamespaceSpecifier') {
                return;
              } // default specifiers are always first


              if (node.specifiers[0].type === 'ImportDefaultSpecifier') {
                return fixer.replaceText(node, "import " + node.specifiers[0].local.name + " from '@emotion/styled';\nimport { " + node.specifiers.filter(function (x) {
                  return x.type === 'ImportSpecifier';
                }).map(function (x) {
                  return x.local.name === x.imported.name ? x.local.name : x.imported.name + " as " + x.local.name;
                }).join(', ') + " } from 'emotion';");
              }

              return fixer.replaceText(node.source, "'emotion'");
            }
          });
        }
      }
    };
  }
};

var noVanilla = {
  meta: {
    fixable: 'code'
  },
  create: function create(context) {
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.value === 'emotion') {
          context.report({
            node: node.source,
            message: "Vanilla emotion should not be used"
          });
        }
      }
    };
  }
};

/**
 * @fileoverview Choose between string or object syntax
 * @author alex-pex
 */
function isStringStyle(node) {
  if (node.type === 'TaggedTemplateExpression') {
    // shorthand notation
    // eg: styled.h1` color: red; `
    if (node.tag.type === 'MemberExpression' && node.tag.object.name === 'styled') {
      // string syntax used
      return true;
    } // full notation
    // eg: styled('h1')` color: red; `


    if (node.tag.type === 'CallExpression' && node.tag.callee.name === 'styled') {
      // string syntax used
      return true;
    }
  }

  return false;
}

function isObjectStyle(node) {
  if (node.type === 'CallExpression') {
    // shorthand notation
    // eg: styled.h1({ color: 'red' })
    if (node.callee.type === 'MemberExpression' && node.callee.object.name === 'styled') {
      // object syntax used
      return true;
    } // full notation
    // eg: styled('h1')({ color: 'red' })


    if (node.callee.type === 'CallExpression' && node.callee.callee.name === 'styled') {
      // object syntax used
      return true;
    }
  }

  return false;
} // ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------


var MSG_PREFER_STRING_STYLE = 'Styles should be written using strings.';
var MSG_PREFER_OBJECT_STYLE = 'Styles should be written using objects.';
var syntaxPreference = {
  meta: {
    docs: {
      description: 'Choose between string or object styles',
      category: 'Stylistic Issues',
      recommended: false
    },
    fixable: null,
    // or "code" or "whitespace"
    schema: [{
      enum: ['string', 'object']
    }]
  },
  create: function create(context) {
    return {
      TaggedTemplateExpression: function TaggedTemplateExpression(node) {
        var preferedSyntax = context.options[0];

        if (isStringStyle(node) && preferedSyntax === 'object') {
          context.report({
            node: node,
            message: MSG_PREFER_OBJECT_STYLE
          });
        }
      },
      CallExpression: function CallExpression(node) {
        var preferedSyntax = context.options[0];

        if (isObjectStyle(node) && preferedSyntax === 'string') {
          context.report({
            node: node,
            message: MSG_PREFER_STRING_STYLE
          });
        }
      }
    };
  }
};

var styledImport = {
  meta: {
    fixable: 'code'
  },
  create: function create(context) {
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.value === 'react-emotion') {
          var newImportPath = '@emotion/styled';
          context.report({
            node: node.source,
            message: "styled should be imported from @emotion/styled",
            fix: node.specifiers.length === 1 && node.specifiers[0].type === 'ImportDefaultSpecifier' ? function (fixer) {
              return fixer.replaceText(node.source, "'" + newImportPath + "'");
            } : undefined
          });
        }
      }
    };
  }
};

var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/; // TODO: handling this case
// <div css={`color:hotpink;`} />
// to
// <div css={css`color:hotpink;`} /> + import { css }

var jsxImport = {
  meta: {
    fixable: 'code'
  },
  create: function create(context) {
    return {
      JSXAttribute: function JSXAttribute(node) {
        if (node.name.name !== 'css') {
          return;
        }

        var hasJsxImport = false;
        var emotionCoreNode = null;
        var local = null;
        var sourceCode = context.getSourceCode();
        sourceCode.ast.body.forEach(function (x) {
          if (x.type === 'ImportDeclaration' && x.source.value === '@emotion/core') {
            emotionCoreNode = x;

            if (x.specifiers.length === 1 && x.specifiers[0].type === 'ImportNamespaceSpecifier') {
              hasJsxImport = true;
              local = x.specifiers[0].local.name + '.jsx';
            } else {
              var jsxSpecifier = x.specifiers.find(function (x) {
                return x.type === 'ImportSpecifier' && x.imported.name === 'jsx';
              });

              if (jsxSpecifier) {
                hasJsxImport = true;
                local = jsxSpecifier.local.name;
              }
            }
          }
        });
        var hasSetPragma = false;

        if (context.settings.react && context.settings.react.pragma === 'jsx') {
          hasSetPragma = true;
        }

        var pragma = sourceCode.getAllComments().find(function (node) {
          return JSX_ANNOTATION_REGEX.test(node.value);
        });
        var match = pragma && pragma.value.match(JSX_ANNOTATION_REGEX);

        if (match && (match[1] === local || !local && match[1] === 'jsx')) {
          hasSetPragma = true;
        }

        if (!hasJsxImport || !hasSetPragma) {
          context.report({
            node: node,
            message: 'The css prop can only be used if jsx from @emotion/core is imported and it is set as the jsx pragma',
            fix: function fix(fixer) {
              if (hasJsxImport) {
                return fixer.insertTextBefore(emotionCoreNode, "/** @jsx " + local + " */\n");
              }

              if (hasSetPragma) {
                if (emotionCoreNode) {
                  var lastSpecifier = emotionCoreNode.specifiers[emotionCoreNode.specifiers.length - 1];

                  if (lastSpecifier.type === 'ImportDefaultSpecifier') {
                    return fixer.insertTextAfter(lastSpecifier, ', { jsx }');
                  }

                  return fixer.insertTextAfter(lastSpecifier, ', jsx');
                }

                return fixer.insertTextBefore(sourceCode.ast.body[0], "import { jsx } from '@emotion/core'\n");
              }

              return fixer.insertTextBefore(sourceCode.ast.body[0], "/** @jsx jsx */\nimport { jsx } from '@emotion/core'\n");
            }
          });
          return;
        }

        if (node.value.type === 'JSXExpressionContainer' && node.value.expression.type === 'TemplateLiteral') {
          var cssSpecifier = emotionCoreNode.specifiers.find(function (x) {
            return x.imported.name === 'css';
          });
          context.report({
            node: node,
            message: 'Template literals should be replaced with tagged template literals using `css` when using the css prop',
            fix: function fix(fixer) {
              if (cssSpecifier) {
                return fixer.insertTextBefore(node.value.expression, cssSpecifier.local.name);
              }

              var lastSpecifier = emotionCoreNode.specifiers[emotionCoreNode.specifiers.length - 1];

              if (context.getScope().variables.some(function (x) {
                return x.name === 'css';
              })) {
                return [fixer.insertTextAfter(lastSpecifier, ", css as _css"), fixer.insertTextBefore(node.value.expression, '_css')];
              }

              return [fixer.insertTextAfter(lastSpecifier, ", css"), fixer.insertTextBefore(node.value.expression, 'css')];
            }
          });
        }
      }
    };
  }
};

var rules = {
  'import-from-emotion': importFromEmotion,
  'no-vanilla': noVanilla,
  'syntax-preference': syntaxPreference,
  'styled-import': styledImport,
  'jsx-import': jsxImport
};

exports.rules = rules;
