"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var importFromEmotion = {
  meta: {
    fixable: "code"
  },
  create: function(context) {
    return {
      ImportDeclaration: function(node) {
        "react-emotion" === node.source.value && node.specifiers.some(function(x) {
          return "ImportDefaultSpecifier" !== x.type;
        }) && context.report({
          node: node.source,
          message: "emotion's exports should be imported directly from emotion rather than from react-emotion",
          fix: function(fixer) {
            if ("ImportNamespaceSpecifier" !== node.specifiers[0].type) return "ImportDefaultSpecifier" === node.specifiers[0].type ? fixer.replaceText(node, "import " + node.specifiers[0].local.name + " from '@emotion/styled';\nimport { " + node.specifiers.filter(function(x) {
              return "ImportSpecifier" === x.type;
            }).map(function(x) {
              return x.local.name === x.imported.name ? x.local.name : x.imported.name + " as " + x.local.name;
            }).join(", ") + " } from 'emotion';") : fixer.replaceText(node.source, "'emotion'");
          }
        });
      }
    };
  }
}, noVanilla = {
  meta: {
    fixable: "code"
  },
  create: function(context) {
    return {
      ImportDeclaration: function(node) {
        "emotion" === node.source.value && context.report({
          node: node.source,
          message: "Vanilla emotion should not be used"
        });
      }
    };
  }
};

function isStringStyle(node) {
  if ("TaggedTemplateExpression" === node.type) {
    if ("MemberExpression" === node.tag.type && "styled" === node.tag.object.name) return !0;
    if ("CallExpression" === node.tag.type && "styled" === node.tag.callee.name) return !0;
  }
  return !1;
}

function isObjectStyle(node) {
  if ("CallExpression" === node.type) {
    if ("MemberExpression" === node.callee.type && "styled" === node.callee.object.name) return !0;
    if ("CallExpression" === node.callee.type && "styled" === node.callee.callee.name) return !0;
  }
  return !1;
}

var MSG_PREFER_STRING_STYLE = "Styles should be written using strings.", MSG_PREFER_OBJECT_STYLE = "Styles should be written using objects.", syntaxPreference = {
  meta: {
    docs: {
      description: "Choose between string or object styles",
      category: "Stylistic Issues",
      recommended: !1
    },
    fixable: null,
    schema: [ {
      enum: [ "string", "object" ]
    } ]
  },
  create: function(context) {
    return {
      TaggedTemplateExpression: function(node) {
        var preferedSyntax = context.options[0];
        isStringStyle(node) && "object" === preferedSyntax && context.report({
          node: node,
          message: MSG_PREFER_OBJECT_STYLE
        });
      },
      CallExpression: function(node) {
        var preferedSyntax = context.options[0];
        isObjectStyle(node) && "string" === preferedSyntax && context.report({
          node: node,
          message: MSG_PREFER_STRING_STYLE
        });
      }
    };
  }
}, styledImport = {
  meta: {
    fixable: "code"
  },
  create: function(context) {
    return {
      ImportDeclaration: function(node) {
        if ("react-emotion" === node.source.value) {
          context.report({
            node: node.source,
            message: "styled should be imported from @emotion/styled",
            fix: 1 === node.specifiers.length && "ImportDefaultSpecifier" === node.specifiers[0].type ? function(fixer) {
              return fixer.replaceText(node.source, "'@emotion/styled'");
            } : void 0
          });
        }
      }
    };
  }
}, JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/, jsxImport = {
  meta: {
    fixable: "code"
  },
  create: function(context) {
    return {
      JSXAttribute: function(node) {
        if ("css" === node.name.name) {
          var hasJsxImport = !1, emotionCoreNode = null, local = null, sourceCode = context.getSourceCode();
          sourceCode.ast.body.forEach(function(x) {
            if ("ImportDeclaration" === x.type && "@emotion/core" === x.source.value) if (emotionCoreNode = x, 
            1 === x.specifiers.length && "ImportNamespaceSpecifier" === x.specifiers[0].type) hasJsxImport = !0, 
            local = x.specifiers[0].local.name + ".jsx"; else {
              var jsxSpecifier = x.specifiers.find(function(x) {
                return "ImportSpecifier" === x.type && "jsx" === x.imported.name;
              });
              jsxSpecifier && (hasJsxImport = !0, local = jsxSpecifier.local.name);
            }
          });
          var hasSetPragma = !1;
          context.settings.react && "jsx" === context.settings.react.pragma && (hasSetPragma = !0);
          var pragma = sourceCode.getAllComments().find(function(node) {
            return JSX_ANNOTATION_REGEX.test(node.value);
          }), match = pragma && pragma.value.match(JSX_ANNOTATION_REGEX);
          if (match && (match[1] === local || !local && "jsx" === match[1]) && (hasSetPragma = !0), 
          hasJsxImport && hasSetPragma) {
            if ("JSXExpressionContainer" === node.value.type && "TemplateLiteral" === node.value.expression.type) {
              var cssSpecifier = emotionCoreNode.specifiers.find(function(x) {
                return "css" === x.imported.name;
              });
              context.report({
                node: node,
                message: "Template literals should be replaced with tagged template literals using `css` when using the css prop",
                fix: function(fixer) {
                  if (cssSpecifier) return fixer.insertTextBefore(node.value.expression, cssSpecifier.local.name);
                  var lastSpecifier = emotionCoreNode.specifiers[emotionCoreNode.specifiers.length - 1];
                  return context.getScope().variables.some(function(x) {
                    return "css" === x.name;
                  }) ? [ fixer.insertTextAfter(lastSpecifier, ", css as _css"), fixer.insertTextBefore(node.value.expression, "_css") ] : [ fixer.insertTextAfter(lastSpecifier, ", css"), fixer.insertTextBefore(node.value.expression, "css") ];
                }
              });
            }
          } else context.report({
            node: node,
            message: "The css prop can only be used if jsx from @emotion/core is imported and it is set as the jsx pragma",
            fix: function(fixer) {
              if (hasJsxImport) return fixer.insertTextBefore(emotionCoreNode, "/** @jsx " + local + " */\n");
              if (hasSetPragma) {
                if (emotionCoreNode) {
                  var lastSpecifier = emotionCoreNode.specifiers[emotionCoreNode.specifiers.length - 1];
                  return "ImportDefaultSpecifier" === lastSpecifier.type ? fixer.insertTextAfter(lastSpecifier, ", { jsx }") : fixer.insertTextAfter(lastSpecifier, ", jsx");
                }
                return fixer.insertTextBefore(sourceCode.ast.body[0], "import { jsx } from '@emotion/core'\n");
              }
              return fixer.insertTextBefore(sourceCode.ast.body[0], "/** @jsx jsx */\nimport { jsx } from '@emotion/core'\n");
            }
          });
        }
      }
    };
  }
}, rules = {
  "import-from-emotion": importFromEmotion,
  "no-vanilla": noVanilla,
  "syntax-preference": syntaxPreference,
  "styled-import": styledImport,
  "jsx-import": jsxImport
};

exports.rules = rules;
